<!DOCTYPE html>

<html>
<head>
    <title>4D Perception Engine - W-Enhanced Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background: #000000;
            font-family: 'Courier New', monospace;
            color: white;
            overflow-x: hidden;
        }
        
        @keyframes glitch {
            0%, 100% { text-shadow: 2px 2px #00ffff, -2px -2px #ff00ff; }
            50% { text-shadow: -2px -2px #00ffff, 2px 2px #ff00ff; }
        }
        
        h1 { 
            text-align: center;
            margin-bottom: 5px;
            font-size: 36px;
            background: linear-gradient(90deg, #00ffff, #00ff00, #ffff00, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glitch 3s ease-in-out infinite;
        }
        
        .subtitle {
            text-align: center;
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 13px;
            letter-spacing: 3px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .github-badge {
            text-align: center;
            margin-bottom: 15px;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 12px;
            background: linear-gradient(135deg, #00ff00, #00ffff);
            color: #000;
            border-radius: 15px;
            font-weight: bold;
            font-size: 11px;
            margin: 0 4px;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }
        
        .main-view {
            max-width: 1900px;
            margin: 0 auto;
            background: linear-gradient(135deg, #001530, #1a0033, #000a1a);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.4);
            position: relative;
        }
        
        .main-view::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 255, 0.03) 2px,
                rgba(0, 255, 255, 0.03) 4px
            );
            pointer-events: none;
            animation: scan 8s linear infinite;
        }
        
        @keyframes scan {
            0% { transform: translateY(0); }
            100% { transform: translateY(50px); }
        }
        
        .process-flow {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 15px 0;
        }
        
        .step-panel {
            background: #000a1a;
            border: 3px solid;
            border-radius: 12px;
            padding: 15px;
            position: relative;
            transition: all 0.3s;
        }
        
        .step-panel:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 15px 40px rgba(0, 255, 255, 0.6);
        }
        
        .step-1 { border-color: #ffff00; }
        .step-2 { border-color: #00ff00; }
        .step-3 { border-color: #ff00ff; }
        
        .step-number {
            position: absolute;
            top: -12px;
            left: 15px;
            background: #000;
            padding: 4px 12px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 12px;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px currentColor; }
            50% { box-shadow: 0 0 20px currentColor; }
        }
        
        .step-1 .step-number { 
            color: #ffff00; 
            border: 2px solid #ffff00;
        }
        .step-2 .step-number { 
            color: #00ff00; 
            border: 2px solid #00ff00;
        }
        .step-3 .step-number { 
            color: #ff00ff; 
            border: 2px solid #ff00ff;
        }
        
        .step-title {
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            margin: 8px 0 12px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .step-1 .step-title { color: #ffff00; }
        .step-2 .step-title { color: #00ff00; }
        .step-3 .step-title { color: #ff00ff; }
        
        canvas {
            border: 2px solid;
            background: #000000;
            display: block;
            margin: 8px auto;
            border-radius: 8px;
            cursor: crosshair;
        }
        
        .step-1 canvas { border-color: #ffff00; }
        .step-2 canvas { border-color: #00ff00; }
        .step-3 canvas { border-color: #ff00ff; }
        
        .step-description {
            font-size: 10px;
            color: #888;
            text-align: center;
            margin-top: 8px;
            line-height: 1.3;
        }
        
        .controls {
            background: #001020;
            border: 2px solid #00ffff;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }
        
        .control-group {
            background: #002030;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #004060;
            transition: all 0.2s;
        }
        
        .control-group:hover {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .control-label {
            display: block;
            margin-bottom: 6px;
            font-size: 9px;
            color: #00ffff;
            text-transform: uppercase;
        }
        
        .value-display {
            color: #00ff00;
            font-weight: bold;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 4px 0;
        }
        
        .capture-section {
            background: linear-gradient(135deg, #003300, #004444, #002222);
            border: 3px solid #00ff00;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.4);
            animation: borderPulse 3s ease-in-out infinite;
        }
        
        @keyframes borderPulse {
            0%, 100% { border-color: #00ff00; }
            50% { border-color: #00ffff; }
        }
        
        .capture-title {
            font-size: 20px;
            color: #00ff00;
            font-weight: bold;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .capture-btn {
            background: linear-gradient(135deg, #00ff00, #00ffff);
            color: #000;
            border: none;
            padding: 15px 40px;
            border-radius: 10px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            box-shadow: 0 5px 25px rgba(0, 255, 0, 0.5);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .capture-btn:hover {
            transform: scale(1.15) rotate(2deg);
            box-shadow: 0 10px 50px rgba(0, 255, 255, 0.9);
        }
        
        .info-panel {
            background: #001020;
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }
        
        .info-item {
            background: #002030;
            padding: 10px;
            border-radius: 8px;
            border-left: 3px solid #00ff00;
        }
        
        .info-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        
        .info-value {
            font-size: 14px;
            color: #00ff00;
            font-weight: bold;
        }
        
        .w-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 0, 255, 0.2);
            border: 2px solid #ff00ff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: bold;
        }
        
        .w-value {
            color: #ff00ff;
            font-size: 16px;
        }
        
    </style>
</head>
<body>
    <h1>üåå 4D PERCEPTION ENGINE üåå</h1>
    <div class="subtitle">‚ú® RAY-TRACED DIMENSIONAL REALITY ‚ú®</div>
    
    <div class="github-badge">
        <span class="badge">üöÄ INTERACTIVE</span>
        <span class="badge">üëÅÔ∏è 4D VISION</span>
        <span class="badge">üéÆ W-ENHANCED</span>
    </div>
    
    <div class="main-view">
        
        <!-- INFO PANEL -->
        <div class="info-panel">
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Observer Position</div>
                    <div class="info-value" id="obs-pos-display">(0.0, 0.0, 4.0, 0.0)</div>
                </div>
                <div class="info-item">
                    <div class="info-label">W Dimension</div>
                    <div class="info-value" style="color: #ff00ff;" id="w-highlight">0.0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Visible Objects</div>
                    <div class="info-value" id="visible-objects">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Dimensional Level</div>
                    <div class="info-value" id="dim-level">4D ‚Üí 3D ‚Üí 1D</div>
                </div>
            </div>
        </div>
        
        <!-- THE THREE STEP PROCESS -->
        <div class="process-flow">
            
            <!-- STEP 1: RAY TRACING -->
            <div class="step-panel step-1">
                <div class="step-number">STEP 1</div>
                <div class="step-title">‚ö° RAY TRACING</div>
                <div class="w-indicator">
                    W: <span class="w-value" id="w-ind-1">0.0</span>
                </div>
                <canvas id="canvas-step1" width="550" height="450"></canvas>
                <div class="step-description">
                    Light rays from observer through 4D hyperspace<br>
                    Colors shift DRAMATICALLY with W position
                </div>
            </div>
            
            <!-- STEP 2: OBSERVER'S 3D VIEW -->
            <div class="step-panel step-2">
                <div class="step-number">STEP 2</div>
                <div class="step-title">üëÅÔ∏è 3D PERCEPTION</div>
                <div class="w-indicator">
                    W: <span class="w-value" id="w-ind-2">0.0</span>
                </div>
                <canvas id="canvas-step2" width="550" height="450"></canvas>
                <div class="step-description">
                    Observer's volumetric 3D construction<br>
                    W affects size, color, and visibility
                </div>
            </div>
            
            <!-- STEP 3: 1D COLLAPSE -->
            <div class="step-panel step-3">
                <div class="step-number">STEP 3</div>
                <div class="step-title">üìè 1D COLLAPSE</div>
                <canvas id="canvas-step3" width="550" height="450"></canvas>
                <div class="step-description">
                    Final 1D line (X-axis only)<br>
                    Ultimate dimensional reduction: 4D ‚Üí 1D
                </div>
            </div>
            
        </div>
        
        <!-- CAPTURE SECTION -->
        <div class="capture-section">
            <div class="capture-title">üì∏ CAPTURE REALITY SNAPSHOT</div>
            <button class="capture-btn" onclick="captureFullProcess()">
                üé¨ GENERATE & DOWNLOAD
            </button>
            <div style="font-size: 11px; color: #888; margin-top: 12px;">
                High-res export ‚Ä¢ 4D ‚Üí 3D ‚Üí 1D cascade ‚Ä¢ Portfolio ready üöÄ
            </div>
        </div>
        
        <!-- CONTROLS -->
        <div class="controls">
            <h3 style="color: #00ffff; margin-top: 0; text-align: center; letter-spacing: 2px; font-size: 14px;">‚öôÔ∏è HYPERSPACE NAVIGATION</h3>
            
            <div class="control-grid">
                <div class="control-group">
                    <label class="control-label">
                        X: <span class="value-display" id="obs-x-display">0.0</span>
                    </label>
                    <input type="range" id="obs-x" min="-6" max="6" step="0.1" value="0">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        Y: <span class="value-display" id="obs-y-display">0.0</span>
                    </label>
                    <input type="range" id="obs-y" min="-6" max="6" step="0.1" value="0">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        Z: <span class="value-display" id="obs-z-display">4.0</span>
                    </label>
                    <input type="range" id="obs-z" min="0.5" max="12" step="0.1" value="4">
                </div>
                
                <div class="control-group" style="background: rgba(255, 0, 255, 0.1); border-color: #ff00ff;">
                    <label class="control-label" style="color: #ff00ff;">
                        ‚ö° W (4D): <span class="value-display" style="color: #ff00ff;" id="obs-w-display">0.0</span>
                    </label>
                    <input type="range" id="obs-w" min="-5" max="5" step="0.1" value="0">
                    <div style="font-size: 8px; color: #ff00ff; margin-top: 3px;">MOVE THIS! Watch colors shift!</div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        FOV: <span class="value-display" id="fov-val-display">90¬∞</span>
                    </label>
                    <input type="range" id="fov" min="60" max="140" step="5" value="90">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        Ray Power: <span class="value-display" id="ray-brightness-display">3.5</span>
                    </label>
                    <input type="range" id="ray-brightness" min="1" max="6" step="0.5" value="3.5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        Spin Speed: <span class="value-display" id="rotation-display">1.0</span>
                    </label>
                    <input type="range" id="rotation-speed" min="0" max="5" step="0.1" value="1">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        Brightness: <span class="value-display" id="brightness-display">2.0</span>
                    </label>
                    <input type="range" id="brightness" min="0.5" max="4" step="0.1" value="2">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        W Effect: <span class="value-display" id="w-effect-display">3.0</span>
                    </label>
                    <input type="range" id="w-effect" min="1" max="5" step="0.5" value="3">
                    <div style="font-size: 8px; color: #666; margin-top: 3px;">How much W changes appearance</div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        Trails: <span class="value-display" id="trails-display">ON</span>
                    </label>
                    <input type="range" id="show-trails" min="0" max="1" step="1" value="1">
                </div>
            </div>
        </div>
        
    </div>
    
    <div style="text-align: center; margin: 20px; color: #666; font-size: 11px;">
        <span style="color: #00ffff;">#4DPerception</span> ‚Ä¢ 
        <span style="color: #00ff00;">#RayTracing</span> ‚Ä¢ 
        <span style="color: #ff00ff;">#4thDimension</span> ‚Ä¢ 
        üíö Built with love for dimensional exploration
    </div>
    
    <script>
    console.log("üåå 4D PERCEPTION ENGINE - W-ENHANCED + 1D EDITION üåå");
    
    // ============================================
    // PARTICLE TRAIL
    // ============================================
    
    class ParticleTrail {
        constructor() {
            this.particles = [];
        }
        
        add(x, y, color) {
            this.particles.push({
                x, y, color,
                life: 1.0,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2
            });
        }
        
        update() {
            this.particles = this.particles.filter(p => {
                p.life -= 0.02;
                p.x += p.vx;
                p.y += p.vy;
                return p.life > 0;
            });
        }
        
        draw(ctx) {
            this.particles.forEach(p => {
                ctx.fillStyle = p.color.replace('1)', `${p.life})`);
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3 * p.life, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    }
    
    // ============================================
    // HYPERCUBE
    // ============================================
    
    class Hypercube4D {
        constructor() {
            this.vertices = [];
            for (let x of [-1, 1]) {
                for (let y of [-1, 1]) {
                    for (let z of [-1, 1]) {
                        for (let w of [-1, 1]) {
                            this.vertices.push([x, y, z, w]);
                        }
                    }
                }
            }
            this.edges = this.generateEdges();
            this.center = [0, 0, 0, 0];
            this.pulse = 0;
        }
        
        generateEdges() {
            const edges = [];
            for (let i = 0; i < this.vertices.length; i++) {
                for (let j = i + 1; j < this.vertices.length; j++) {
                    let diff = 0;
                    for (let k = 0; k < 4; k++) {
                        if (this.vertices[i][k] !== this.vertices[j][k]) diff++;
                    }
                    if (diff === 1) edges.push([i, j]);
                }
            }
            return edges;
        }
        
        rotate(angles) {
            return this.vertices.map(v => {
                let [x, y, z, w] = v;
                
                let cos = Math.cos(angles.xy), sin = Math.sin(angles.xy);
                [x, y] = [x * cos - y * sin, x * sin + y * cos];
                
                cos = Math.cos(angles.zw); sin = Math.sin(angles.zw);
                [z, w] = [z * cos - w * sin, z * sin + w * cos];
                
                cos = Math.cos(angles.xw); sin = Math.sin(angles.xw);
                [x, w] = [x * cos - w * sin, x * sin + w * cos];
                
                const pulseFactor = 1 + Math.sin(this.pulse) * 0.05;
                return [x * pulseFactor, y * pulseFactor, z * pulseFactor, w * pulseFactor];
            });
        }
    }
    
    // ============================================
    // RAY TRACER WITH ENHANCED W EFFECTS
    // ============================================
    
    class RayTracer4D {
        constructor(observerPos, fov, brightness, wEffect) {
            this.observerPos = observerPos;
            this.fov = fov;
            this.brightness = brightness;
            this.wEffect = wEffect;
        }
        
        traceRay(targetPoint) {
            const dx = targetPoint[0] - this.observerPos[0];
            const dy = targetPoint[1] - this.observerPos[1];
            const dz = targetPoint[2] - this.observerPos[2];
            const dw = targetPoint[3] - this.observerPos[3];
            
            const distance = Math.sqrt(dx*dx + dy*dy + dz*dz + dw*dw);
            
            const direction = [dx / distance, dy / distance, dz / distance, dw / distance];
            
            // W-distance affects intensity DRAMATICALLY
            const wDistance = Math.abs(dw);
            const wFalloff = 1 / (1 + wDistance * this.wEffect);
            const intensity = (this.brightness / (1 + distance * distance * 0.06)) * wFalloff;
            
            // W-based color shift (EXAGGERATED)
            const wShift = ((targetPoint[3] - this.observerPos[3]) + 6) / 12; // 0 to 1
            
            return {
                origin: this.observerPos,
                direction: direction,
                distance: distance,
                intensity: intensity,
                target: targetPoint,
                wShift: wShift,
                wDistance: wDistance
            };
        }
        
        rayTo3D(ray, canvasWidth, canvasHeight) {
            const [dx, dy, dz, dw] = ray.direction;
            const dist = ray.distance;
            
            if (dist < 0.1) return null;
            
            // W-distance affects scale DRAMATICALLY
            const wScaleFactor = 1 / (1 + ray.wDistance * this.wEffect * 0.5);
            const scale = (1.8 / (dist * 0.25 + 0.1)) * wScaleFactor;
            const fovScale = Math.tan((this.fov * Math.PI / 180) / 2);
            
            const screenX = (dx * scale * fovScale * canvasWidth * 0.85) + canvasWidth / 2;
            const screenY = (-dy * scale * fovScale * canvasHeight * 0.85) + canvasHeight / 2;
            
            // Size affected by W
            const size = Math.max(5, 40 / (dist + 0.3)) * wScaleFactor;
            
            return {
                x: screenX,
                y: screenY,
                size: size,
                intensity: ray.intensity,
                distance: ray.distance,
                depth: dz,
                wShift: ray.wShift,
                wDistance: ray.wDistance,
                visible: screenX >= -100 && screenX <= canvasWidth + 100 && 
                        screenY >= -100 && screenY <= canvasHeight + 100
            };
        }
        
        rayTo1D(ray, canvasWidth, canvasHeight) {
            // Just X coordinate, everything else collapsed
            const [dx, dy, dz, dw] = ray.direction;
            const dist = ray.distance;
            
            if (dist < 0.1) return null;
            
            // W affects brightness in 1D view
            const wFalloff = 1 / (1 + ray.wDistance * this.wEffect);
            const xPosition = dx / Math.abs(dz + 0.1); // Perspective
            
            return {
                x: (xPosition * canvasWidth * 0.4) + canvasWidth / 2,
                intensity: ray.intensity * wFalloff,
                distance: ray.distance,
                wShift: ray.wShift,
                size: Math.max(8, 30 / (dist + 0.5))
            };
        }
    }
    
    // ============================================
    // GLOBALS
    // ============================================
    
    const hypercube = new Hypercube4D();
    let observerPos = [0, 0, 4, 0];
    let fov = 90;
    let brightness = 2.0;
    let rayBrightness = 3.5;
    let wEffect = 3.0; // HIGHER = more W influence
    let showTrails = true;
    
    const trail1 = new ParticleTrail();
    const trail2 = new ParticleTrail();
    const trail3 = new ParticleTrail();
    
    const ctx1 = document.getElementById('canvas-step1').getContext('2d');
    const ctx2 = document.getElementById('canvas-step2').getContext('2d');
    const ctx3 = document.getElementById('canvas-step3').getContext('2d');
    
    let angles = { xy: 0, zw: 0, xw: 0 };
    let rotationSpeed = 1.0;
    const mapScale = 45;
    
    // ============================================
    // STEP 1: RAY TRACING (W-ENHANCED)
    // ============================================
    
    function renderStep1(ctx, canvas, vertices, hypercube, observerPos, rayBrightness, wEffect, scale) {
        ctx.fillStyle = showTrails ? 'rgba(0, 0, 0, 0.3)' : '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (showTrails) {
            trail1.update();
            trail1.draw(ctx);
        }
        
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        
        // Grid
        ctx.strokeStyle = `rgba(17, 17, 17, ${0.5 + Math.sin(Date.now() * 0.001) * 0.3})`;
        ctx.lineWidth = 1;
        for (let i = -5; i <= 5; i++) {
            ctx.beginPath();
            ctx.moveTo(cx + i * scale, 15);
            ctx.lineTo(cx + i * scale, canvas.height - 15);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(15, cy - i * scale);
            ctx.lineTo(canvas.width - 15, cy - i * scale);
            ctx.stroke();
        }
        
        // Center
        const pulseFactor = 1 + Math.sin(Date.now() * 0.003) * 0.3;
        ctx.fillStyle = '#ff00ff';
        ctx.shadowBlur = 25 * pulseFactor;
        ctx.shadowColor = '#ff00ff';
        ctx.beginPath();
        ctx.arc(cx, cy, 10 * pulseFactor, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        const obsX = cx + observerPos[0] * scale;
        const obsY = cy - observerPos[1] * scale;
        
        // RAYS WITH DRAMATIC W-BASED COLORING
        vertices.forEach(v => {
            const vx = cx + v[0] * scale;
            const vy = cy - v[1] * scale;
            
            const dx = v[0] - observerPos[0];
            const dy = v[1] - observerPos[1];
            const dz = v[2] - observerPos[2];
            const dw = v[3] - observerPos[3];
            
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz + dw*dw);
            const wDist = Math.abs(dw);
            
            // W affects intensity
            const wFalloff = 1 / (1 + wDist * wEffect);
            const intensity = (rayBrightness / (1 + dist * dist * 0.03)) * wFalloff;
            
            // HUE DRAMATICALLY SHIFTS WITH W
            const wShift = ((v[3] - observerPos[3]) + 6) / 12;
            const hue = wShift * 300; // Full spectrum based on W!
            
            ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${Math.min(1, intensity * 0.9)})`;
            ctx.lineWidth = Math.max(2, intensity * 5);
            ctx.shadowBlur = 25 * intensity;
            ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
            ctx.beginPath();
            ctx.moveTo(obsX, obsY);
            ctx.lineTo(vx, vy);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            if (showTrails && Math.random() < 0.12) {
                const t = Math.random();
                const px = obsX + (vx - obsX) * t;
                const py = obsY + (vy - obsY) * t;
                trail1.add(px, py, `hsla(${hue}, 100%, 60%, 1)`);
            }
        });
        
        // Hypercube
        const breathe = 1 + Math.sin(hypercube.pulse) * 0.1;
        ctx.lineWidth = 3 * breathe;
        hypercube.edges.forEach(([i, j]) => {
            const [x1, y1, z1, w1] = vertices[i];
            const [x2, y2, z2, w2] = vertices[j];
            
            // W-based coloring
            const wAvg = ((w1 + w2) / 2 - observerPos[3] + 6) / 12;
            const hue = wAvg * 300;
            
            ctx.strokeStyle = `hsl(${hue}, 100%, 65%)`;
            ctx.shadowBlur = 14 * breathe;
            ctx.shadowColor = `hsl(${hue}, 100%, 65%)`;
            ctx.globalAlpha = 0.7;
            
            ctx.beginPath();
            ctx.moveTo(cx + x1 * scale, cy - y1 * scale);
            ctx.lineTo(cx + x2 * scale, cy - y2 * scale);
            ctx.stroke();
        });
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        
        // Vertices with W coloring
        vertices.forEach(v => {
            const [x, y, z, w] = v;
            const wShift = ((w - observerPos[3]) + 6) / 12;
            const hue = wShift * 300;
            const sparkle = 1 + Math.sin(Date.now() * 0.005 + x + y) * 0.3;
            
            ctx.fillStyle = `hsl(${hue}, 100%, 70%)`;
            ctx.shadowBlur = 20 * sparkle;
            ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
            ctx.beginPath();
            ctx.arc(cx + x * scale, cy - y * scale, 7 * sparkle, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        });
        
        // Observer
        ctx.fillStyle = 'rgba(0, 255, 0, 0.15)';
        ctx.beginPath();
        ctx.arc(obsX, obsY, 55, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.shadowBlur = 35;
        ctx.shadowColor = '#00ff00';
        ctx.beginPath();
        ctx.arc(obsX, obsY, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = '#00ff00';
        ctx.font = 'bold 13px monospace';
        ctx.fillText('YOU', obsX + 22, obsY - 22);
    }
    
    // ============================================
    // STEP 2: 3D VOLUMETRIC (W-ENHANCED)
    // ============================================
    
    function renderStep2(ctx, canvas, vertices, hypercube, rayTracer) {
        ctx.fillStyle = showTrails ? 'rgba(0, 0, 0, 0.4)' : '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (showTrails) {
            trail2.update();
            trail2.draw(ctx);
        }
        
        const rays = vertices.map(v => rayTracer.traceRay(v));
        const projected = rays.map((ray, i) => ({
            ray: ray,
            screen: rayTracer.rayTo3D(ray, canvas.width, canvas.height),
            index: i
        })).filter(({ screen }) => screen !== null);
        
        projected.sort((a, b) => (b.screen ? b.screen.depth : 0) - (a.screen ? a.screen.depth : 0));
        
        const visibleCount = projected.filter(({ screen }) => screen && screen.visible).length;
        document.getElementById('visible-objects').textContent = visibleCount;
        
        // Edges with W-based colors
        ctx.lineWidth = 5;
        hypercube.edges.forEach(([i, j]) => {
            const p1Data = projected.find(({ index }) => index === i);
            const p2Data = projected.find(({ index }) => index === j);
            
            if (p1Data && p2Data && p1Data.screen && p2Data.screen) {
                const s1 = p1Data.screen;
                const s2 = p2Data.screen;
                
                const avgIntensity = (p1Data.ray.intensity + p2Data.ray.intensity) / 2;
                const avgWShift = (p1Data.ray.wShift + p2Data.ray.wShift) / 2;
                
                const brightness = Math.max(40, Math.min(85, 50 + avgIntensity * 50));
                const hue = avgWShift * 300; // Full rainbow based on W!
                
                ctx.strokeStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                ctx.shadowBlur = 28 * avgIntensity;
                ctx.shadowColor = `hsl(${hue}, 100%, ${brightness}%)`;
                ctx.globalAlpha = Math.max(0.5, avgIntensity * 1.4);
                
                ctx.beginPath();
                ctx.moveTo(s1.x, s1.y);
                ctx.lineTo(s2.x, s2.y);
                ctx.stroke();
                
                if (showTrails && Math.random() < 0.08) {
                    const t = Math.random();
                    const px = s1.x + (s2.x - s1.x) * t;
                    const py = s1.y + (s2.y - s1.y) * t;
                    trail2.add(px, py, `hsla(${hue}, 100%, 60%, 1)`);
                }
            }
        });
        
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        
        // Vertices with W coloring
        projected.forEach(({ ray, screen }) => {
            if (!screen) return;
            
            const brightness = Math.max(40, Math.min(85, 50 + ray.intensity * 50));
            const hue = ray.wShift * 300;
            
            ctx.shadowBlur = 38 * ray.intensity;
            ctx.shadowColor = `hsl(${hue}, 100%, ${brightness}%)`;
            
            ctx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, screen.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            if (ray.distance < 5 && screen.visible) {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, ray.intensity * 2)})`;
                ctx.font = 'bold 10px monospace';
                ctx.fillText(ray.distance.toFixed(1), screen.x + screen.size + 5, screen.y - 5);
            }
        });
        
        // Crosshair
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 18;
        ctx.shadowColor = '#00ff00';
        ctx.beginPath();
        ctx.moveTo(cx - 28, cy);
        ctx.lineTo(cx + 28, cy);
        ctx.moveTo(cx, cy - 28);
        ctx.lineTo(cx, cy + 28);
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Depth rings
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.lineWidth = 2;
        for (let i = 1; i <= 3; i++) {
            ctx.beginPath();
            ctx.arc(cx, cy, 35 * i, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
    
    // ============================================
    // STEP 3: 1D COLLAPSE
    // ============================================
    
    function renderStep3(ctx, canvas, vertices, hypercube, rayTracer) {
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (showTrails) {
            trail3.update();
            trail3.draw(ctx);
        }
        
        const rays = vertices.map(v => rayTracer.traceRay(v));
        const projected = rays.map((ray, i) => ({
            ray: ray,
            pos1D: rayTracer.rayTo1D(ray, canvas.width, canvas.height),
            index: i
        })).filter(({ pos1D }) => pos1D !== null);
        
        projected.sort((a, b) => b.ray.distance - a.ray.distance);
        
        const cy = canvas.height / 2;
        
        // Draw 1D axis
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(50, cy);
        ctx.lineTo(canvas.width - 50, cy);
        ctx.stroke();
        
        // Tick marks
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 2;
        for (let i = -5; i <= 5; i++) {
            const x = canvas.width / 2 + i * 50;
            ctx.beginPath();
            ctx.moveTo(x, cy - 10);
            ctx.lineTo(x, cy + 10);
            ctx.stroke();
        }
        
        // Draw 1D points with W-based colors
        projected.forEach(({ ray, pos1D }) => {
            if (!pos1D) return;
            
            const hue = ray.wShift * 300;
            const brightness = Math.max(40, Math.min(80, 50 + ray.intensity * 50));
            
            ctx.shadowBlur = 40 * ray.intensity;
            ctx.shadowColor = `hsl(${hue}, 100%, ${brightness}%)`;
            
            ctx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
            ctx.beginPath();
            ctx.arc(pos1D.x, cy, pos1D.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            if (showTrails && Math.random() < 0.1) {
                trail3.add(pos1D.x, cy, `hsla(${hue}, 100%, 60%, 1)`);
            }
        });
        
        // Label
        ctx.fillStyle = '#ff00ff';
        ctx.font = 'bold 16px monospace';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff00ff';
        ctx.fillText('X-AXIS ONLY', canvas.width / 2, 40);
        ctx.shadowBlur = 0;
        
        ctx.font = '11px monospace';
        ctx.fillStyle = '#888';
        ctx.fillText('All other dimensions (Y, Z, W) collapsed', canvas.width / 2, 60);
        
        // Show count
        ctx.fillStyle = '#ff00ff';
        ctx.font = '13px monospace';
        ctx.fillText(`${projected.length} points on line`, canvas.width / 2, canvas.height - 30);
    }
    
    // ============================================
    // CAPTURE
    // ============================================
    
    function captureFullProcess() {
        console.log("üì∏ Capturing W-ENHANCED + 1D edition...");
        
        const currentVertices = hypercube.rotate(angles);
        const captureRayTracer = new RayTracer4D(observerPos, fov, brightness, wEffect);
        
        const composite = document.createElement('canvas');
        composite.width = 1920;
        composite.height = 1080;
        const ctx = composite.getContext('2d');
        
        // Background
        const gradient = ctx.createLinearGradient(0, 0, composite.width, composite.height);
        gradient.addColorStop(0, '#000510');
        gradient.addColorStop(0.5, '#1a0033');
        gradient.addColorStop(1, '#000510');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, composite.width, composite.height);
        
        // Title
        ctx.fillStyle = '#00ffff';
        ctx.font = 'bold 50px monospace';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 25;
        ctx.shadowColor = '#00ffff';
        ctx.fillText('üåå 4D PERCEPTION ENGINE üåå', composite.width / 2, 70);
        ctx.shadowBlur = 0;
        
        ctx.font = '22px monospace';
        ctx.fillStyle = '#00ff00';
        ctx.fillText(`Observer at (${observerPos.map(n => n.toFixed(1)).join(', ')})`, composite.width / 2, 110);
        
        // Render steps
        const temp1 = document.createElement('canvas');
        temp1.width = 580;
        temp1.height = 580;
        const temp2 = document.createElement('canvas');
        temp2.width = 580;
        temp2.height = 580;
        const temp3 = document.createElement('canvas');
        temp3.width = 580;
        temp3.height = 580;
        
        renderStep1(temp1.getContext('2d'), temp1, currentVertices, hypercube, observerPos, rayBrightness, wEffect, 58);
        renderStep2(temp2.getContext('2d'), temp2, currentVertices, hypercube, captureRayTracer);
        renderStep3(temp3.getContext('2d'), temp3, currentVertices, hypercube, captureRayTracer);
        
        const startY = 150;
        
        // Draw steps
        [
            [temp1, '#ffff00', 'STEP 1: RAY TRACING', 'Light rays (W affects color!)', 30],
            [temp2, '#00ff00', "STEP 2: 3D PERCEPTION", '3D volumetric with W-shift', 670],
            [temp3, '#ff00ff', 'STEP 3: 1D COLLAPSE', 'Pure X-axis line', 1310]
        ].forEach(([tempCanvas, color, title, desc, x]) => {
            ctx.strokeStyle = color;
            ctx.lineWidth = 5;
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.strokeRect(x, startY, 600, 700);
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = color;
            ctx.font = 'bold 22px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(title, x + 300, startY - 12);
            ctx.drawImage(tempCanvas, x + 10, startY + 10);
            ctx.font = '14px monospace';
            ctx.fillStyle = '#888';
            ctx.fillText(desc, x + 300, startY + 630);
        });
        
        // Footer
        const footerY = 920;
        ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
        ctx.fillRect(30, footerY, composite.width - 60, 120);
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(30, footerY, composite.width - 60, 120);
        
        ctx.font = '16px monospace';
        ctx.textAlign = 'left';
        
        const info = [
            ['Position:', `(${observerPos.map(n => n.toFixed(2)).join(', ')})`, '#00ffff', '#00ff00', 60, footerY + 35],
            ['W Effect:', `${wEffect}x`, '#00ffff', '#ff00ff', 60, footerY + 65],
            ['Rays:', `${currentVertices.length}`, '#00ffff', '#00ff00', 60, footerY + 95],
            ['Method:', '4D Ray Tracing', '#00ffff', '#00ff00', 500, footerY + 35],
            ['Cascade:', '4D ‚Üí 3D ‚Üí 1D', '#00ffff', '#00ff00', 500, footerY + 65],
            ['FOV:', `${fov}¬∞`, '#00ffff', '#00ff00', 500, footerY + 95],
            ['Mode:', 'W-ENHANCED', '#00ffff', '#ff00ff', 1000, footerY + 35],
            ['Effects:', 'ALL ON', '#00ffff', '#00ff00', 1000, footerY + 65],
            ['Status:', 'üöÄ READY', '#00ffff', '#00ff00', 1000, footerY + 95]
        ];
        
        info.forEach(([label, value, labelColor, valueColor, x, y]) => {
            ctx.fillStyle = labelColor;
            ctx.fillText(label, x, y);
            ctx.fillStyle = valueColor;
            ctx.fillText(value, x + 130, y);
        });
        
        // Tags
        ctx.font = '15px monospace';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#888';
        ctx.fillText('#4DPerception #RayTracing #4thDimension #HyperspaceTech', composite.width / 2, footerY + 95);
        
        // Timestamp
        ctx.textAlign = 'right';
        ctx.fillStyle = '#444';
        ctx.font = '13px monospace';
        const now = new Date();
        ctx.fillText(now.toLocaleString(), composite.width - 60, footerY + 35);
        
        // Download
        composite.toBlob(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `4d-perception-w-enhanced-${now.getTime()}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log('‚úÖ W-ENHANCED CAPTURE SAVED! üéâ');
        });
    }
    
    // ============================================
    // CONTROLS
    // ============================================
    
    function updateControls() {
        observerPos[0] = parseFloat(document.getElementById('obs-x').value);
        observerPos[1] = parseFloat(document.getElementById('obs-y').value);
        observerPos[2] = parseFloat(document.getElementById('obs-z').value);
        observerPos[3] = parseFloat(document.getElementById('obs-w').value);
        
        document.getElementById('obs-x-display').textContent = observerPos[0].toFixed(1);
        document.getElementById('obs-y-display').textContent = observerPos[1].toFixed(1);
        document.getElementById('obs-z-display').textContent = observerPos[2].toFixed(1);
        document.getElementById('obs-w-display').textContent = observerPos[3].toFixed(1);
        
        document.getElementById('obs-pos-display').textContent = `(${observerPos.map(n => n.toFixed(1)).join(', ')})`;
        document.getElementById('w-highlight').textContent = observerPos[3].toFixed(1);
        
        // Update W indicators
        ['w-ind-1', 'w-ind-2'].forEach(id => {
            document.getElementById(id).textContent = observerPos[3].toFixed(1);
        });
    }
    
    ['obs-x', 'obs-y', 'obs-z', 'obs-w'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateControls);
    });
    
    document.getElementById('fov').addEventListener('input', (e) => {
        fov = parseInt(e.target.value);
        document.getElementById('fov-val-display').textContent = fov + '¬∞';
    });
    
    document.getElementById('ray-brightness').addEventListener('input', (e) => {
        rayBrightness = parseFloat(e.target.value);
        document.getElementById('ray-brightness-display').textContent = rayBrightness.toFixed(1);
    });
    
    document.getElementById('rotation-speed').addEventListener('input', (e) => {
        rotationSpeed = parseFloat(e.target.value);
        document.getElementById('rotation-display').textContent = rotationSpeed.toFixed(1);
    });
    
    document.getElementById('brightness').addEventListener('input', (e) => {
        brightness = parseFloat(e.target.value);
        document.getElementById('brightness-display').textContent = brightness.toFixed(1);
    });
    
    document.getElementById('w-effect').addEventListener('input', (e) => {
        wEffect = parseFloat(e.target.value);
        document.getElementById('w-effect-display').textContent = wEffect.toFixed(1);
    });
    
    document.getElementById('show-trails').addEventListener('input', (e) => {
        showTrails = parseInt(e.target.value) === 1;
        document.getElementById('trails-display').textContent = showTrails ? 'ON' : 'OFF';
    });
    
    // Animation
    function animate() {
        angles.xy += rotationSpeed * 0.005;
        angles.zw += rotationSpeed * 0.007;
        angles.xw += rotationSpeed * 0.003;
        hypercube.pulse += 0.05;
        
        const rotated = hypercube.rotate(angles);
        const rayTracer = new RayTracer4D(observerPos, fov, brightness, wEffect);
        
        renderStep1(ctx1, document.getElementById('canvas-step1'), rotated, hypercube, observerPos, rayBrightness, wEffect, mapScale);
        renderStep2(ctx2, document.getElementById('canvas-step2'), rotated, hypercube, rayTracer);
        renderStep3(ctx3, document.getElementById('canvas-step3'), rotated, hypercube, rayTracer);
        
        requestAnimationFrame(animate);
    }
    
    updateControls();
    animate();
    console.log("‚úÖ 4D ENGINE - W-ENHANCED + 1D READY! üöÄ");
    
    </script>
</body>
</html>

